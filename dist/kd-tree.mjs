function g(h){this.content=[],this.scoreFunction=h}g.prototype={push:function(h){this.content.push(h),this.bubbleUp(this.content.length-1)},pop:function(){let h=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.sinkDown(0)),h},peek:function(){return this.content[0]},remove:function(h){for(let t=this.content.length,e=0;e<t;e++)if(this.content[e]==h){let n=this.content.pop();e!=t-1&&(this.content[e]=n,this.scoreFunction(n)<this.scoreFunction(h)?this.bubbleUp(e):this.sinkDown(e));return}throw new Error("Node not found.")},size:function(){return this.content.length},bubbleUp:function(h){for(let t=this.content[h];h>0;){let e=Math.floor((h+1)/2)-1,n=this.content[e];if(this.scoreFunction(t)<this.scoreFunction(n))this.content[e]=t,this.content[h]=n,h=e;else break}},sinkDown:function(h){for(let t=this.content.length,e=this.content[h],n=this.scoreFunction(e);;){let i=(h+1)*2,l=i-1,r=null;if(l<t){let u=this.content[l],s=this.scoreFunction(u);s<n&&(r=l)}if(i<t){let f=this.content[i],c=this.scoreFunction(f);c<(r==null?n:s)&&(r=i)}if(r!=null)this.content[h]=this.content[r],this.content[r]=e,h=r;else break}}};let a=class{left=null;right=null;obj;parent;dimension;constructor(t,e,n){let i=this;i.obj=t,i.parent=n,i.dimension=e}},p=class{#t;#n;root;get dimensions(){return this.#t}get metric(){return this.#n}#i(t,e,n){let i=this,l=e%i.#t.length;if(t.length===0)return null;if(t.length===1)return new a(t[0],l,n);t.sort((s,f)=>s[i.#t[l]]-f[i.#t[l]]);let r=t.length>>1,u=new a(t[r],l,n);return u.left=i.#i(t.slice(0,r),e+1,u),u.right=i.#i(t.slice(r+1),e+1,u),u}#l(t){let e=this;t.left&&(t.left.parent=t,e.#l(t.left)),t.right&&(t.right.parent=t,e.#l(t.right))}#a(t){this.root=t,this.#l(this.root)}#r(t,e,n){if(t===null)return e;let i=dimensions[t.dimension];return n[i]<t.obj[i]?upThis.#r(t.left,t,n):upThis.#r(t.right,t,n)}#h(t,e){let n=this;if(t===null)return null;if(t.obj===e)return t;let i=n.#t[t.dimension];return e[i]<t.obj[i]?n.#h(t.left,e):n.#h(t.right,e)}#e(t,e){let n=this;if(t===null)return null;let i=n.#t[e];if(t.dimension===e)return t.left!=null?n.#e(t.left,e):t;let l=t.obj[i],r=n.#e(t.left,e),u=n.#e(t.right,e),s=t;return r!=null&&r.obj[i]<l&&(s=r),u!=null&&u.obj[i]<s.obj[i]&&(s=u),s}#u(t){let e=this;if(t.left===null&&t.right===null){if(t.parent===null){e.root=null;return}let n=e.#t[t.parent.dimension];t.obj[n]<t.parent.obj[n]?t.parent.left=null:t.parent.right=null;return}if(t.right==null){let n=e.#e(t.left,t.dimension),i=n.obj;e.#u(n),t.right=t.left,t.left=null,t.obj=i}else{let n=e.#e(t.right,t.dimension),i=n.obj;e.#u(n),t.obj=i}}#f(t,e,n,i){n.push([t,e]),n.size()>i&&n.pop()}#s(t,e,n,i){let l=this,r=l.#t[t.dimension],u=l.#n(e,t.obj),s=[];for(let o=0;o<l.#t.length;o++)o===t.dimension?s[l.#t[o]]=e[l.#t[o]]:s[l.#t[o]]=t.obj[l.#t[o]];let f=l.#n(s,t.obj);if(t.right===null&&t.left===null){(n.size()<i||u<n.peek()[1])&&l.#f(t,u,n,i);return}let c;if(t.right===null?c=t.left:t.left===null?c=t.right:e[r]<t.obj[r]?c=t.left:c=t.right,l.#s(c,e,n,i),(n.size()<i||u<n.peek()[1])&&l.#f(t,u,n,i),n.size()<i||Math.abs(f)<n.peek()[1]){let o;c===t.left?o=t.right:o=t.left,o!=null&&l.#s(o,e,n,i)}}#o(t){return t==null?0:Math.max(this.#o(t.left),this.#o(t.right))+1}#c(t){return t==null?0:this.#c(t.left)+this.#c(t.right)+1}toJSON(t){let e=this;t||(t=e.root);let n=new a(t.obj,t.dimension,null);return t.left&&(n.left=e.toJSON(t.left)),t.right&&(n.right=e.toJSON(t.right)),n}insert(t){let e=this,n=e.#r(e.root,null,t);if(n===null){e.root=new a(t,0,null);return}let i=new a(t,(n.dimension+1)%e.#t.length,n),l=e.#t[n.dimension];t[l]<n.obj[l]?n.left=i:n.right=i}remove(t){let e=this,n=e.#h(e.root,t);n!==null&&e.#u(n)}nearest(t,e,n){let i=new g(r=>-r[1]);if(n)for(let r=0;r<e;r++)i.push([null,n]);this.root&&this.#s(this.root,t,i,e);let l=[];for(let r=0;r<Math.min(e,i.content.length);r++)i.content[r][0]&&l.push([i.content[r][0].obj,i.content[r][1]]);return l}balanceFactor(){let t=this;return t.#o(t.root)/Math.log(t.#c(t.root))/Math.LN2}constructor(t,e,n){let i=this;i.#t=n,i.#n=e,Array.isArray(t)?i.root=i.#i(t,0,null):i.#a(t,e,n)}};export{g as KDBinaryHeap,p as KDTree};
/**
 * k-d Tree JavaScript - v1.1
 *
 * https://github.com/ubilabs/kd-tree-javascript
 * https://github.com/ltgcgo/kd-tree
 * https://codeberg.org/ltgc/kd-tree
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @author Lumière Élevé <ble-m@ltgc.cc>, 2025
 * @author Lightingale Community https://ltgc.cc, 2025
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */
