"use strict";let a=class{content=[];scoreFunction;push(t){let e=this;e.content.push(t),e.bubbleUp(e.content.length-1)}pop(){let t=this,e=t.content[0],l=t.content.pop();return t.content.length>0&&(t.content[0]=l,t.sinkDown(0)),e}peek(){return this.content[0]}remove(t){let e=this,l=e.content.length;for(let i=0;i<l;i++)if(e.content[i]==t){let n=e.content.pop();i!=l-1&&(e.content[i]=n,e.scoreFunction(n)<e.scoreFunction(t)?e.bubbleUp(i):e.sinkDown(i));return}throw new Error("The specified node was not found.")}size(){return this.content.length}bubbleUp(t){let e=this,l=e.content[t];for(;t>0;){let i=(t+1>>1)-1,n=e.content[i];if(e.scoreFunction(l)<e.scoreFunction(n))e.content[i]=l,e.content[t]=n,t=i;else break}}sinkDown(t){let e=this,l=e.content.length,i=e.content[t],n=e.scoreFunction(i);for(;;){let r=t+1<<1,h=r-1,u=null;if(h<l){let c=e.content[h];e.scoreFunction(c)<n&&(u=h)}if(r<l){let c=e.content[r];e.scoreFunction(c)<n&&(u=r)}if(u!=null)e.content[t]=e.content[u],e.content[u]=i,t=u;else break}}constructor(t){this.scoreFunction=t}},o=class{left=null;right=null;obj;parent;dimension;constructor(t,e,l){let i=this;i.obj=t,i.parent=l,i.dimension=e}},T=class{#t;#l;root;get dimensions(){return this.#t}get metric(){return this.#l}#i(t,e,l){let i=this,n=e%i.#t.length;if(t.length===0)return null;if(t.length===1)return new o(t[0],n,l);t.sort((u,c)=>u[i.#t[n]]-c[i.#t[n]]);let r=t.length>>1,h=new o(t[r],n,l);return h.left=i.#i(t.slice(0,r),e+1,h),h.right=i.#i(t.slice(r+1),e+1,h),h}#n(t){let e=this;t.left&&(t.left.parent=t,e.#n(t.left)),t.right&&(t.right.parent=t,e.#n(t.right))}#g(t){this.root=t,this.#n(this.root)}#r(t,e,l){if(t===null)return e;let i=dimensions[t.dimension];return l[i]<t.obj[i]?upThis.#r(t.left,t,l):upThis.#r(t.right,t,l)}#h(t,e){let l=this;if(t===null)return null;if(t.obj===e)return t;let i=l.#t[t.dimension];return e[i]<t.obj[i]?l.#h(t.left,e):l.#h(t.right,e)}#e(t,e){let l=this;if(t===null)return null;let i=l.#t[e];if(t.dimension===e)return t.left!=null?l.#e(t.left,e):t;let n=t.obj[i],r=l.#e(t.left,e),h=l.#e(t.right,e),u=t;return r!=null&&r.obj[i]<n&&(u=r),h!=null&&h.obj[i]<u.obj[i]&&(u=h),u}#u(t){let e=this;if(t.left===null&&t.right===null){if(t.parent===null){e.root=null;return}let l=e.#t[t.parent.dimension];t.obj[l]<t.parent.obj[l]?t.parent.left=null:t.parent.right=null;return}if(t.right==null){let l=e.#e(t.left,t.dimension),i=l.obj;e.#u(l),t.right=t.left,t.left=null,t.obj=i}else{let l=e.#e(t.right,t.dimension),i=l.obj;e.#u(l),t.obj=i}}#o(t,e,l,i){l.push([t,e]),l.size()>i&&l.pop()}#s(t,e,l,i){let n=this,r=n.#t[t.dimension],h=n.#l(e,t.obj),u=[];for(let s=0;s<n.#t.length;s++)s===t.dimension?u[n.#t[s]]=e[n.#t[s]]:u[n.#t[s]]=t.obj[n.#t[s]];let c=n.#l(u,t.obj);if(t.right===null&&t.left===null){(l.size()<i||h<l.peek()[1])&&n.#o(t,h,l,i);return}let f;if(t.right===null?f=t.left:t.left===null?f=t.right:e[r]<t.obj[r]?f=t.left:f=t.right,n.#s(f,e,l,i),(l.size()<i||h<l.peek()[1])&&n.#o(t,h,l,i),l.size()<i||Math.abs(c)<l.peek()[1]){let s;f===t.left?s=t.right:s=t.left,s!=null&&n.#s(s,e,l,i)}}#f(t){return t==null?0:Math.max(this.#f(t.left),this.#f(t.right))+1}#c(t){return t==null?0:this.#c(t.left)+this.#c(t.right)+1}toJSON(t){let e=this;t||(t=e.root);let l=new o(t.obj,t.dimension,null);return t.left&&(l.left=e.toJSON(t.left)),t.right&&(l.right=e.toJSON(t.right)),l}insert(t){let e=this,l=e.#r(e.root,null,t);if(l===null){e.root=new o(t,0,null);return}let i=new o(t,(l.dimension+1)%e.#t.length,l),n=e.#t[l.dimension];t[n]<l.obj[n]?l.left=i:l.right=i}remove(t){let e=this,l=e.#h(e.root,t);l!==null&&e.#u(l)}nearest(t,e,l){let i=new a(r=>-r[1]);if(l)for(let r=0;r<e;r++)i.push([null,l]);this.root&&this.#s(this.root,t,i,e);let n=[];for(let r=0;r<Math.min(e,i.content.length);r++)i.content[r][0]&&n.push([i.content[r][0].obj,i.content[r][1]]);return n}balanceFactor(){let t=this;return t.#f(t.root)/Math.log(t.#c(t.root))/Math.LN2}constructor(t,e,l){let i=this;i.#t=l,i.#l=e,Array.isArray(t)?i.root=i.#i(t,0,null):i.#g(t,e,l)}};export{a as KDBinaryHeap,T as KDTree};
/**
 * k-d Tree JavaScript - v1.1
 *
 * https://github.com/ubilabs/kd-tree-javascript
 * https://github.com/ltgcgo/kd-tree
 * https://codeberg.org/ltgc/kd-tree
 *
 * @author Mircea Pricop <pricop@ubilabs.net>, 2012
 * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @author Lumière Élevé <ble-m@ltgc.cc>, 2025
 * @author Lightingale Community https://ltgc.cc, 2025
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */
